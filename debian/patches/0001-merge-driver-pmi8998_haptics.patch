From dca98baf5c3cc3a56c46d7424898a039750db3ec Mon Sep 17 00:00:00 2001
From: Caleb Connolly <caleb@connolly.tech>
Date: Sat, 17 Apr 2021 20:11:23 +0100
Subject: [PATCH 01/12] merge driver/pmi8998_haptics

Squashed commit of the following:

commit ad2d6c6e6ca44a42f731d6a338bf267283d2c77f
Author: Caleb Connolly <caleb@connolly.tech>
Date:   Sat Apr 17 16:53:34 2021 +0100

    dts: sdm845: beryllium: enable haptics

    Enable the haptics node and set the play rate from downstream.

    Signed-off-by: Caleb Connolly <caleb@connolly.tech>

commit ac8708e3707b7e94b159284d2e1a40bbfc3523af
Author: Caleb Connolly <caleb@connolly.tech>
Date:   Wed Feb 24 13:14:51 2021 +0000

    dts: sdm845: oneplus: enable haptics

    Enable the haptics node and set the play rate from downstream.

    Signed-off-by: Caleb Connolly <caleb@connolly.tech>

commit 81f99854215f3f7c5c0ade3aabe4b60c345d191d
Author: Caleb Connolly <caleb@connolly.tech>
Date:   Thu Jan 28 19:45:25 2021 +0000

    arm64: dts: pmi8998: add pmi8998_haptics

    Add a node for the pmi8998 haptics device.

    Signed-off-by: Caleb Connolly <caleb@connolly.tech>

commit 16898721f66b84497e4277be63e3ce33a4dc7c7d
Author: Caleb Connolly <caleb@connolly.tech>
Date:   Thu Jan 28 19:41:37 2021 +0000

    input: pmi8998_haptics: introduce new haptics driver

    Introduce a haptics driver for the pmi8998 haptics engine used by
    several generations of Qualcomm SoCs (MSM8996 through SDM845).

    Here we only implement a small subset of common operations, advanced
    features like customising the wave pattern, driving the haptics via pwm
    and several other features are either stubbed or left unimplemented for
    now.

    Signed-off-by: Caleb Connolly <caleb@connolly.tech>

commit d434405aaab7d0ebc516b68a8fc4100922d7f5ef
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 11 15:16:13 2021 -0700

    Linux 5.12-rc7

commit 7d900724913cb293620a05c5a3134710db95d0d9
Merge: add6b92660b3 53b74fa990bf
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 11 11:53:36 2021 -0700

    Merge tag 'for-5.12-rc6-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux

    Pull btrfs fix from David Sterba:
     "One more patch that we'd like to get to 5.12 before release.

      It's changing where and how the superblock is stored in the zoned
      mode. It is an on-disk format change but so far there are no
      implications for users as the proper mkfs support hasn't been merged
      and is waiting for the kernel side to settle.

      Until now, the superblocks were derived from the zone index, but zone
      size can differ per device. This is changed to be based on fixed
      offset values, to make it independent of the device zone size.

      The work on that got a bit delayed, we discussed the exact locations
      to support potential device sizes and usecases. (Partially delayed
      also due to my vacation.) Having that in the same release where the
      zoned mode is declared usable is highly desired, there are userspace
      projects that need to be updated to recognize the feature. Pushing
      that to the next release would make things harder to test"

    * tag 'for-5.12-rc6-tag' of git://git.kernel.org/pub/scm/linux/kernel/git/kdave/linux:
      btrfs: zoned: move superblock logging zone location

commit add6b92660b3dca65465d3bd7710b4b1338f34f0
Merge: 06f838e02d3b 6d48b7912cc7
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 11 11:47:03 2021 -0700

    Merge tag 'locking-urgent-2021-04-11' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip

    Pull locking fixlets from Ingo Molnar:
     "Two minor fixes: one for a Clang warning, the other improves an
      ambiguous/confusing kernel log message"

    * tag 'locking-urgent-2021-04-11' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      lockdep: Address clang -Wformat warning printing for %hd
      lockdep: Add a missing initialization hint to the "INFO: Trying to register non-static key" message

commit 06f838e02d3b6e161df08c910e12e8366f1cb465
Merge: 52e44129fba5 632a1c209b87
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sun Apr 11 11:42:18 2021 -0700

    Merge tag 'x86_urgent_for_v5.12-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip

    Pull x86 fixes from Borislav Petkov:

     - Fix the vDSO exception handling return path to disable interrupts
       again.

     - A fix for the CE collector to return the proper return values to its
       callers which are used to convey what the collector has done with the
       error address.

    * tag 'x86_urgent_for_v5.12-rc7' of git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip:
      x86/traps: Correct exc_general_protection() and math_error() return paths
      RAS/CEC: Correct ce_add_elem()'s returned values

commit 52e44129fba5cfc4e351fdb5e45849afc74d9a53
Merge: efc2da9241e6 0760fa3d8f7f
Author: Linus Torvalds <torvalds@linux-foundation.org>
Date:   Sat Apr 10 12:51:12 2021 -0700

    Merge branch 'for-5.12-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/dennis/percpu

    Pull percpu fix from Dennis Zhou:
     "This contains a fix for sporadically failing atomic percpu
      allocations.

      I only caught it recently while I was reviewing a new series [1] and
      simultaneously saw reports by btrfs in xfstests [2] and [3].

      In v5.9, memcg accounting was extended to percpu done by adding a
      second type of chunk. I missed an interaction with the free page float
      count used to ensure we can support atomic allocations. If one type of
      chunk has no free pages, but the other has enough to satisfy the free
      page float requirement, we will not repopulate the free pages for the
      former type of chunk. This led to the sporadically failing atomic
      allocations"

    Link: https://lore.kernel.org/linux-mm/20210324190626.564297-1-guro@fb.com/ [1]
    Link: https://lore.kernel.org/linux-mm/20210401185158.3275.409509F4@e16-tech.com/ [2]
    Link: https://lore.kernel.org/linux-mm/CAL3q7H5RNBjCi708GH7jnczAOe0BLnacT9C+OBgA-Dx9jhB6SQ@mail.gmail.com/ [3]

    * 'for-5.12-fixes' of git://git.kernel.org/pub/scm/linux/kernel/git/dennis/percpu:
      percpu: make pcpu_nr_empty_pop_pages per chunk type

commit 53b74fa990bf76f290aa5930abfcf37424a1a865
Author: Naohiro Aota <naohiro.aota@wdc.com>
Date:   Thu Apr 8 17:25:28 2021 +0900

    btrfs: zoned: move superblock logging zone location

    Moves the location of the superblock logging zones. The new locations of
    the logging zones are now determined based on fixed block addresses
    instead of on fixed zone numbers.

    The old placement method based on fixed zone numbers causes problems when
    one needs to inspect a file system image without access to the drive zone
    information. In such case, the super block locations cannot be reliably
    determined as the zone size is unknown. By locating the superblock logging
    zones using fixed addresses, we can scan a dumped file system image without
    the zone information since a super block copy will always be present at or
    after the fixed known locations.

    Introduce the following three pairs of zones containing fixed offset
    locations, regardless of the device zone size.

      - primary superblock: offset   0B (and the following zone)
      - first copy:         offset 512G (and the following zone)
      - Second copy:        offset   4T (4096G, and the following zone)

    If a logging zone is outside of the disk capacity, we do not record the
    superblock copy.

    The first copy position is much larger than for a non-zoned filesystem,
    which is at 64M.  This is to avoid overlapping with the log zones for
    the primary superblock. This higher location is arbitrary but allows
    supporting devices with very large zone sizes, plus some space around in
    between.

    Such large zone size is unrealistic and very unlikely to ever be seen in
    real devices. Currently, SMR disks have a zone size of 256MB, and we are
    expecting ZNS drives to be in the 1-4GB range, so this limit gives us
    room to breathe. For now, we only allow zone sizes up to 8GB. The
    maximum zone size that would still fit in the space is 256G.

    The fixed location addresses are somewhat arbitrary, with the intent of
    maintaining superblock reliability for smaller and larger devices, with
    the preference for the latter. For this reason, there are two superblocks
    under the first 1T. This should cover use cases for physical devices and
    for emulated/device-mapper devices.

    The superblock logging zones are reserved for superblock logging and
    never used for data or metadata blocks. Note that we only reserve the
    two zones per primary/copy actually used for superblock logging. We do
    not reserve the ranges of zones possibly containing superblocks with the
    largest supported zone size (0-16GB, 512G-528GB, 4096G-4112G).

    The zones containing the fixed location offsets used to store
    superblocks on a non-zoned volume are also reserved to avoid confusion.

    Signed-off-by: Naohiro Aota <naohiro.aota@wdc.com>
    Signed-off-by: David Sterba <dsterba@suse.com>

commit 0760fa3d8f7fceeea508b98899f1c826e10ffe78
Author: Roman Gushchin <guro@fb.com>
Date:   Wed Apr 7 20:57:33 2021 -0700

    percpu: make pcpu_nr_empty_pop_pages per chunk type

    nr_empty_pop_pages is used to guarantee that there are some free
    populated pages to satisfy atomic allocations. Accounted and
    non-accounted allocations are using separate sets of chunks,
    so both need to have a surplus of empty pages.

    This commit makes pcpu_nr_empty_pop_pages and the corresponding logic
    per chunk type.

    [Dennis]
    This issue came up as I was reviewing [1] and realized I missed this.
    Simultaneously, it was reported btrfs was seeing failed atomic
    allocations in fsstress tests [2] and [3].

    [1] https://lore.kernel.org/linux-mm/20210324190626.564297-1-guro@fb.com/
    [2] https://lore.kernel.org/linux-mm/20210401185158.3275.409509F4@e16-tech.com/
    [3] https://lore.kernel.org/linux-mm/CAL3q7H5RNBjCi708GH7jnczAOe0BLnacT9C+OBgA-Dx9jhB6SQ@mail.gmail.com/

    Fixes: 3c7be18ac9a0 ("mm: memcg/percpu: account percpu memory to memory cgroups")
    Cc: stable@vger.kernel.org # 5.9+
    Signed-off-by: Roman Gushchin <guro@fb.com>
    Tested-by: Filipe Manana <fdmanana@suse.com>
    Signed-off-by: Dennis Zhou <dennis@kernel.org>

commit 632a1c209b8773cb0119fe3aada9f1db14fa357c
Author: Thomas Tai <thomas.tai@oracle.com>
Date:   Thu Apr 8 13:28:33 2021 -0400

    x86/traps: Correct exc_general_protection() and math_error() return paths

    Commit

      334872a09198 ("x86/traps: Attempt to fixup exceptions in vDSO before signaling")

    added return statements which bypass calling cond_local_irq_disable().

    According to

      ca4c6a9858c2 ("x86/traps: Make interrupt enable/disable symmetric in C code"),

    cond_local_irq_disable() is needed because the asm return code no longer
    disables interrupts. Follow the existing code as an example to use "goto
    exit" instead of "return" statement.

     [ bp: Massage commit message. ]

    Fixes: 334872a09198 ("x86/traps: Attempt to fixup exceptions in vDSO before signaling")
    Signed-off-by: Thomas Tai <thomas.tai@oracle.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Reviewed-by: Alexandre Chartre <alexandre.chartre@oracle.com>
    Link: https://lkml.kernel.org/r/1617902914-83245-1-git-send-email-thomas.tai@oracle.com

commit 3a62583c2853b0ab37a57dde79decea210b5fb89
Author: William Roche <william.roche@oracle.com>
Date:   Tue Apr 6 11:28:59 2021 -0400

    RAS/CEC: Correct ce_add_elem()'s returned values

    ce_add_elem() uses different return values to signal a result from
    adding an element to the collector. Commit in Fixes: broke the case
    where the element being added is not found in the array. Correct that.

     [ bp: Rewrite commit message, add kernel-doc comments. ]

    Fixes: de0e0624d86f ("RAS/CEC: Check count_threshold unconditionally")
    Signed-off-by: William Roche <william.roche@oracle.com>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: <stable@vger.kernel.org>
    Link: https://lkml.kernel.org/r/1617722939-29670-1-git-send-email-william.roche@oracle.com

commit 6d48b7912cc72275dc7c59ff961c8bac7ef66a92
Author: Arnd Bergmann <arnd@arndb.de>
Date:   Mon Mar 22 12:55:25 2021 +0100

    lockdep: Address clang -Wformat warning printing for %hd

    Clang doesn't like format strings that truncate a 32-bit
    value to something shorter:

      kernel/locking/lockdep.c:709:4: error: format specifies type 'short' but the argument has type 'int' [-Werror,-Wformat]

    In this case, the warning is a slightly questionable, as it could realize
    that both class->wait_type_outer and class->wait_type_inner are in fact
    8-bit struct members, even though the result of the ?: operator becomes an
    'int'.

    However, there is really no point in printing the number as a 16-bit
    'short' rather than either an 8-bit or 32-bit number, so just change
    it to a normal %d.

    Fixes: de8f5e4f2dc1 ("lockdep: Introduce wait-type checks")
    Signed-off-by: Arnd Bergmann <arnd@arndb.de>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20210322115531.3987555-1-arnd@kernel.org

commit 3a85969e9d912d5dd85362ee37b5f81266e00e77
Author: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
Date:   Sun Mar 21 15:49:13 2021 +0900

    lockdep: Add a missing initialization hint to the "INFO: Trying to register non-static key" message

    Since this message is printed when dynamically allocated spinlocks (e.g.
    kzalloc()) are used without initialization (e.g. spin_lock_init()),
    suggest to developers to check whether initialization functions for objects
    were called, before making developers wonder what annotation is missing.

    [ mingo: Minor tweaks to the message. ]

    Signed-off-by: Tetsuo Handa <penguin-kernel@I-love.SAKURA.ne.jp>
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
    Link: https://lore.kernel.org/r/20210321064913.4619-1-penguin-kernel@I-love.SAKURA.ne.jp
    Signed-off-by: Ingo Molnar <mingo@kernel.org>
---
 arch/arm64/boot/dts/qcom/pmi8998.dtsi         |   38 +
 .../boot/dts/qcom/sdm845-oneplus-common.dtsi  |    6 +
 .../boot/dts/qcom/sdm845-xiaomi-beryllium.dts |    5 +
 drivers/input/misc/Kconfig                    |   12 +
 drivers/input/misc/Makefile                   |    1 +
 drivers/input/misc/pmi8998-haptics.c          | 1118 +++++++++++++++++
 .../dt-bindings/input/qcom,pmi8998-haptics.h  |   31 +
 7 files changed, 1211 insertions(+)
 create mode 100644 drivers/input/misc/pmi8998-haptics.c
 create mode 100644 include/dt-bindings/input/qcom,pmi8998-haptics.h

diff --git a/arch/arm64/boot/dts/qcom/pmi8998.dtsi b/arch/arm64/boot/dts/qcom/pmi8998.dtsi
index d230c510d4b7..f7b32ddf2a8a 100644
--- a/arch/arm64/boot/dts/qcom/pmi8998.dtsi
+++ b/arch/arm64/boot/dts/qcom/pmi8998.dtsi
@@ -1,4 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0
+#include <dt-bindings/input/qcom,pmi8998-haptics.h>
 #include <dt-bindings/interrupt-controller/irq.h>
 #include <dt-bindings/spmi/spmi.h>
 
@@ -41,5 +42,42 @@ lab: lab {
 				interrupt-names = "sc-err", "ocp";
 			};
 		};
+
+		pmi8998_haptics: qcom,haptics@c000 {
+			compatible = "qcom,qpnp-haptics-buffer";
+			reg = <0xc000 0x100>;
+
+			interrupts = <0x3 0xc0 0x0 IRQ_TYPE_EDGE_BOTH>,
+						 <0x3 0xc0 0x1 IRQ_TYPE_EDGE_BOTH>;
+			interrupt-names = "hap-sc-irq", "hap-play-irq"; 
+
+			qcom,wave-shape = <HAP_WAVE_SINE>;
+			qcom,play-mode = <HAP_PLAY_BUFFER>;
+
+			status = "disabled";
+
+			// Unused / unimplemented in code
+
+			// qcom,lra-res-cal-period = <32>;
+			// qcom,play-mode = "direct";
+			// qcom,actuator-type = <HAP_TYPE_LRA>;
+			// qcom,brake-pattern = <0x3 0x3 0x3 0x3>;
+		};
+
+		pmi8998_wled: wled@d800 {
+			#address-cells = <1>;
+			#size-cells = <0>;
+			compatible = "qcom,pmi8998-wled";
+			reg = <0xd800>, <0xd900>;
+			interrupts = <0x3 0xd8 0x2 IRQ_TYPE_EDGE_RISING>;
+			interrupt-names = "short";
+			qcom,current-boost-limit = <970>;
+			qcom,current-limit-microamp = <25000>;
+			qcom,ovp-millivolt = <29600>;
+			qcom,switching-freq = <800>;
+			qcom,enabled-strings = <0 1 2 3>;
+			qcom,num-strings = <4>;
+			status = "disabled";
+		};
 	};
 };
diff --git a/arch/arm64/boot/dts/qcom/sdm845-oneplus-common.dtsi b/arch/arm64/boot/dts/qcom/sdm845-oneplus-common.dtsi
index 8f617f7b6d34..7f4272b36a94 100644
--- a/arch/arm64/boot/dts/qcom/sdm845-oneplus-common.dtsi
+++ b/arch/arm64/boot/dts/qcom/sdm845-oneplus-common.dtsi
@@ -7,6 +7,7 @@
 
 /dts-v1/;
 
+#include <dt-bindings/dma/qcom-gpi.h>
 #include <dt-bindings/gpio/gpio.h>
 #include <dt-bindings/input/linux-event-codes.h>
 #include <dt-bindings/regulator/qcom,rpmh-regulator.h>
@@ -423,6 +424,11 @@ pinconf {
 	};
 };
 
+&pmi8998_haptics {
+	status = "okay";
+	qcom,wave-play-rate-us = <4255>;
+};
+
 &qupv3_id_1 {
 	status = "okay";
 };
diff --git a/arch/arm64/boot/dts/qcom/sdm845-xiaomi-beryllium.dts b/arch/arm64/boot/dts/qcom/sdm845-xiaomi-beryllium.dts
index 86cbae63eaf7..f09b7a4c8c56 100644
--- a/arch/arm64/boot/dts/qcom/sdm845-xiaomi-beryllium.dts
+++ b/arch/arm64/boot/dts/qcom/sdm845-xiaomi-beryllium.dts
@@ -230,6 +230,11 @@ vol_up_pin_a: vol-up-active {
 	};
 };
 
+&pmi8998_haptics {
+	status = "okay";
+	qcom,wave-play-rate-us = <4878>;
+};
+
 &pm8998_pon {
 	resin {
 		compatible = "qcom,pm8941-resin";
diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index ad1b6c90bc4d..06a2bd8c64f8 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -164,6 +164,18 @@ config INPUT_PM8XXX_VIBRATOR
 	  To compile this driver as module, choose M here: the
 	  module will be called pm8xxx-vibrator.
 
+config INPUT_PMI8998_HAPTICS
+	tristate "Qualcomm PMI8998 HAPTICS"
+	depends on ARCH_QCOM
+	select INPUT_FF_MEMLESS
+	help
+	  This option enabled support for the haptics found in pmi8998 PMICs.
+	  Based on the ff-memless interface. Currently this driver provides
+	  a partial implementation and ONLY supports SDM845 SoCs.
+
+	  To compile this driver as module, choose M here: the
+	  module will be called pmi8998-haptics.
+
 config INPUT_PMIC8XXX_PWRKEY
 	tristate "PMIC8XXX power key support"
 	depends on MFD_PM8XXX
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index 7f202ba8f775..2f171ac1d59d 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -59,6 +59,7 @@ obj-$(CONFIG_INPUT_PCF8574)		+= pcf8574_keypad.o
 obj-$(CONFIG_INPUT_PCSPKR)		+= pcspkr.o
 obj-$(CONFIG_INPUT_PM8941_PWRKEY)	+= pm8941-pwrkey.o
 obj-$(CONFIG_INPUT_PM8XXX_VIBRATOR)	+= pm8xxx-vibrator.o
+obj-$(CONFIG_INPUT_PMI8998_HAPTICS) += pmi8998-haptics.o
 obj-$(CONFIG_INPUT_PMIC8XXX_PWRKEY)	+= pmic8xxx-pwrkey.o
 obj-$(CONFIG_INPUT_POWERMATE)		+= powermate.o
 obj-$(CONFIG_INPUT_PWM_BEEPER)		+= pwm-beeper.o
diff --git a/drivers/input/misc/pmi8998-haptics.c b/drivers/input/misc/pmi8998-haptics.c
new file mode 100644
index 000000000000..b9f323cc48fa
--- /dev/null
+++ b/drivers/input/misc/pmi8998-haptics.c
@@ -0,0 +1,1118 @@
+// SPDX-License-Identifier: GPL-2.0-only
+/*
+ * Copyright (c) 2021, Caleb Connolly <caleb@connolly.tech>
+ * 
+ * Based on ./pm8xxx_vibrator.c
+ * 
+ * For implementation details and some rough hardware docs see: https://www.notion.so/calebccff/pmi8998-QPNP-Qcom-Plug-n-Play-haptics-9ccc9240c0f5498f8eb5feb2ff1059e5
+ */
+
+/*
+ * TODO: Add suport for wave shape, play mode, brake?
+ */
+
+#include <dt-bindings/input/qcom,pmi8998-haptics.h>
+
+#include <linux/atomic.h>
+#include <linux/errno.h>
+#include <linux/input.h>
+#include <linux/interrupt.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <linux/log2.h>
+#include <linux/bits.h>
+#include <linux/time.h>
+
+/*
+ * Register and bit definitions
+ */
+
+#define HAP_STATUS_1_REG(chip)		(chip->base + 0x0A)
+#define HAP_BUSY_BIT				BIT(1)
+#define SC_FLAG_BIT					BIT(3)
+#define AUTO_RES_ERROR_BIT			BIT(4)
+
+#define HAP_LRA_AUTO_RES_LO_REG(chip)	(chip->base + 0x0B)
+#define HAP_LRA_AUTO_RES_HI_REG(chip)	(chip->base + 0x0C)
+
+#define HAP_EN_CTL_REG(chip)		(chip->base + 0x46)
+#define HAP_EN_BIT			BIT(7)
+
+#define HAP_EN_CTL2_REG(chip)		(chip->base + 0x48)
+#define BRAKE_EN_BIT				BIT(0)
+
+#define HAP_AUTO_RES_CTRL_REG(chip)	(chip->base + 0x4B)
+#define AUTO_RES_EN_BIT			BIT(7)
+#define AUTO_RES_ERR_RECOVERY_BIT	BIT(3)
+#define AUTO_RES_EN_FLAG_BIT	BIT(0)
+
+#define HAP_CFG1_REG(chip)			(chip->base + 0x4C)
+#define HAP_ACT_TYPE_MASK			BIT(0)
+
+#define HAP_CFG2_REG(chip)		(chip->base + 0x4D)
+#define HAP_LRA_RES_TYPE_MASK		BIT(0)
+
+#define HAP_SEL_REG(chip)			(chip->base + 0x4E)
+#define HAP_WF_SOURCE_MASK			GENMASK(5, 4)
+#define HAP_WF_SOURCE_SHIFT			4
+
+#define HAP_LRA_AUTO_RES_REG(chip)	(chip->base + 0x4F)
+#define LRA_AUTO_RES_MODE_MASK		GENMASK(6, 4)
+#define LRA_AUTO_RES_MODE_SHIFT		4
+#define LRA_HIGH_Z_MASK				GENMASK(3, 2)
+#define LRA_HIGH_Z_SHIFT			2
+#define LRA_RES_CAL_MASK			GENMASK(1, 0)
+#define HAP_RES_CAL_PERIOD_MIN		4
+#define HAP_RES_CAL_PERIOD_MAX		32
+
+#define HAP_VMAX_CFG_REG(chip)		(chip->base + 0x51)
+#define HAP_VMAX_OVD_BIT			BIT(6)
+#define HAP_VMAX_MASK				GENMASK(5, 1)
+#define HAP_VMAX_SHIFT				1
+
+#define HAP_ILIM_CFG_REG(chip)		(chip->base + 0x52)
+#define HAP_ILIM_SEL_MASK			BIT(0)
+#define HAP_ILIM_400_MA				0
+#define HAP_ILIM_800_MA				1
+
+
+#define HAP_SC_DEB_REG(chip)		(chip->base + 0x53)
+#define HAP_SC_DEB_MASK				GENMASK(2, 0)
+#define HAP_SC_DEB_CYCLES_MIN		0
+#define HAP_DEF_SC_DEB_CYCLES		8
+#define HAP_SC_DEB_CYCLES_MAX		32
+
+#define HAP_RATE_CFG1_REG(chip)		(chip->base + 0x54)
+#define HAP_RATE_CFG1_MASK		GENMASK(7, 0)
+#define HAP_RATE_CFG2_SHIFT		8 // As CFG2 is the most significant byte
+
+#define HAP_RATE_CFG2_REG(chip)		(chip->base + 0x55)
+#define HAP_RATE_CFG2_MASK		GENMASK(3, 0)
+
+#define HAP_SC_CLR_REG(chip)		(chip->base + 0x59)
+#define SC_CLR_BIT			BIT(0)
+
+#define HAP_BRAKE_REG(chip)		(chip->base + 0x5C)
+#define HAP_BRAKE_PAT_MASK		0x3
+
+#define HAP_WF_REPEAT_REG(chip)		(chip->base + 0x5E)
+#define WF_REPEAT_MASK			GENMASK(6, 4)
+#define WF_REPEAT_SHIFT			4
+#define WF_REPEAT_MIN			1
+#define WF_REPEAT_MAX			128
+#define WF_S_REPEAT_MASK		GENMASK(1, 0)
+#define WF_S_REPEAT_MIN			1
+#define WF_S_REPEAT_MAX			8
+
+#define HAP_WF_S1_REG(chip)		(chip->base + 0x60)
+#define HAP_WF_SIGN_BIT			BIT(7)
+#define HAP_WF_OVD_BIT			BIT(6)
+#define HAP_WF_SAMP_MAX			GENMASK(5, 1)
+#define HAP_WF_SAMPLE_LEN		8
+
+#define HAP_PLAY_REG(chip)		(chip->base + 0x70)
+#define PLAY_BIT			BIT(7)
+#define PAUSE_BIT			BIT(0)
+
+#define HAP_SEC_ACCESS_REG(chip)	(chip->base + 0xD0)
+#define HAP_SEC_ACCESS_UNLOCK		0xA5
+
+// For pmi8998 AUTO_RES_EN_BIT is written here to enable auto resonance
+// mode, what the h*ck
+#define HAP_TEST2_REG(chip)		(chip->base + 0xE3)
+
+// Values
+#define HAP_VMAX_MIN_MV				116
+#define HAP_VMAX_MAX_MV				3596
+#define HAP_VMAX_MAX_MV_STRONG		3596
+
+#define HAP_WAVE_PLAY_RATE_DEF_US	5715
+#define HAP_WAVE_PLAY_RATE_MIN_US	0
+#define HAP_WAVE_PLAY_RATE_MAX_US	20475
+#define HAP_WAVE_PLAY_TIME_MAX_MS	15000
+
+#define AUTO_RES_ERR_POLL_TIME_NS	(20 * NSEC_PER_MSEC)
+#define HAPTICS_BACK_EMF_DELAY_US	20000
+
+#define HAP_BRAKE_PAT_LEN			4
+#define HAP_WAVE_SAMP_LEN			8
+#define NUM_WF_SET					4
+#define HAP_WAVE_SAMP_SET_LEN		(HAP_WAVE_SAMP_LEN * NUM_WF_SET)
+#define HAP_RATE_CFG_STEP_US		5
+
+#define SC_MAX_COUNT		5
+#define SC_COUNT_RST_DELAY_US	1000000
+
+enum hap_play_control {
+	HAP_STOP,
+	HAP_PAUSE,
+	HAP_PLAY,
+};
+
+/**
+ * struct pmi8998_haptics - struct for qpnp haptics data.
+ */
+struct pmi8998_haptics {
+	struct platform_device *pdev;
+	struct regmap *regmap;
+	struct input_dev *haptics_input_dev;
+	struct work_struct work;
+	u16 base;
+
+	atomic_t active;
+	bool auto_res_enabled;
+	u16 drive_period_code_max_limit;
+	u16 drive_period_code_min_limit;
+
+	int play_irq;
+	int sc_irq;
+	ktime_t last_sc_time;
+	u8 sc_count;
+
+	u8 actuator_type;
+	u8 wave_shape;
+	u8 play_mode;
+	u32 last_play_rate;
+	int magnitude;
+	u32 vmax;
+	u32 current_limit;
+	u32 play_wave_rate;
+	u8 wave_samp_idx;
+
+	u32 wave_samp[HAP_WAVE_SAMP_SET_LEN];
+	u32 brake_pat[HAP_BRAKE_PAT_LEN];
+
+	struct mutex play_lock;
+};
+
+/**
+ * constrain() - Constrain a value to a range
+ * @val: The value to constrain
+ * @min: The minimum allowed value
+ * @max: The maximum allowed value
+ */
+static inline u32 constrain(u32 val, u32 min, u32 max) {
+	return val < min ? min
+		 : (val > max ? max
+		 : val);
+}
+
+static inline bool is_secure_addr(u16 addr)
+{
+	return (addr & 0xFF) > 0xD0;
+}
+
+static int pmi8998_haptics_read(struct pmi8998_haptics *haptics, u16 addr, u8 *val, int len)
+{
+	int ret;
+
+	ret = regmap_bulk_read(haptics->regmap, addr, val, len);
+	if (ret < 0)
+		pr_err("Error reading address: 0x%x, ret %d\n", addr, ret);
+	
+	pr_debug("%s: read 0x%x from 0x%x", __func__, *val, addr);
+
+	return ret;
+}
+
+static int pmi8998_haptics_write(struct pmi8998_haptics *haptics, u16 addr, u8 *val, int len)
+{
+	int ret, i;
+
+	if (is_secure_addr(addr)) {
+		for (i = 0; i < len; i++) {
+			pr_info("%s: unlocking for addr: 0x%x, val: 0x%x", __func__, addr, val[i]);
+			ret = regmap_write(haptics->regmap,
+				HAP_SEC_ACCESS_REG(haptics), HAP_SEC_ACCESS_UNLOCK);
+			if (ret < 0) {
+				pr_err("Error writing unlock code, ret %d\n",
+					ret);
+				return ret;
+			}
+
+			ret = regmap_write(haptics->regmap, addr + i, val[i]);
+			if (ret < 0) {
+				pr_err("Error writing address 0x%x, ret %d\n",
+					addr + i, ret);
+				return ret;
+			}
+		}
+	} else {
+		if (len > 1)
+			ret = regmap_bulk_write(haptics->regmap, addr, val, len);
+		else
+			ret = regmap_write(haptics->regmap, addr, *val);
+	}
+
+	if (ret < 0)
+		pr_err("%s: Error writing address: 0x%x, ret %d\n", __func__, addr, ret);
+
+	return ret;
+}
+
+static int pmi8998_haptics_write_masked(struct pmi8998_haptics *haptics, u16 addr, u8 mask, u8 val)
+{
+	int ret;
+
+	if (is_secure_addr(addr)) {
+		ret = regmap_write(haptics->regmap,
+			HAP_SEC_ACCESS_REG(haptics), HAP_SEC_ACCESS_UNLOCK);
+		if (ret < 0) {
+			pr_err("Error writing unlock code - ret %d\n", ret);
+			return ret;
+		}
+	}
+
+	ret = regmap_update_bits(haptics->regmap, addr, mask, val);
+	if (ret < 0)
+		pr_err("Error writing address: 0x%x - ret %d\n", addr, ret);
+	
+	return ret;
+}
+
+static bool is_haptics_idle(struct pmi8998_haptics *haptics)
+{
+	int ret;
+	u8 val;
+
+	if (haptics->play_mode == HAP_PLAY_DIRECT ||
+			haptics->play_mode == HAP_PLAY_PWM)
+		return true;
+
+	ret = pmi8998_haptics_read(haptics, HAP_STATUS_1_REG(haptics), &val, 1);
+	if (ret < 0 || (val & HAP_BUSY_BIT))
+		return false;
+
+	return true;
+}
+
+static int pmi8998_haptics_module_enable(struct pmi8998_haptics *haptics, bool enable)
+{
+	u8 val;
+	int rc;
+
+	pr_debug("pmi8998_haptics: setting module enable: %d", enable);
+
+	if (!enable) {
+		if (!is_haptics_idle(haptics))
+			pr_debug("Disabling module forcibly\n");
+	}
+
+	val = enable ? HAP_EN_BIT : 0;
+	rc = pmi8998_haptics_write(haptics, HAP_EN_CTL_REG(haptics), &val, 1);
+	if (rc < 0)
+		return rc;
+
+	return 0;
+}
+
+/* configuration api for max voltage */
+static int pmi8998_haptics_write_vmax(struct pmi8998_haptics *haptics)
+{
+	u8 val = 0;
+	int ret;
+	u32 vmax_mv = haptics->vmax;
+
+	pr_debug("Setting vmax to: %d", haptics->vmax);
+
+	vmax_mv = constrain(vmax_mv, HAP_VMAX_MIN_MV, HAP_VMAX_MAX_MV);
+
+	val = DIV_ROUND_CLOSEST(vmax_mv, HAP_VMAX_MIN_MV);
+	val <<= HAP_VMAX_SHIFT;
+	// overdrive only supported on pm660 apparently
+	val &= ~HAP_VMAX_OVD_BIT;
+
+	ret = pmi8998_haptics_write_masked(haptics, HAP_VMAX_CFG_REG(haptics),
+			HAP_VMAX_MASK | HAP_VMAX_OVD_BIT, val);
+	return ret;
+}
+
+/* configuration api for ilim */
+static int pmi8998_haptics_write_current_limit(struct pmi8998_haptics *haptics)
+{
+	int ret;
+
+	haptics->current_limit = constrain(haptics->current_limit, HAP_ILIM_400_MA, HAP_ILIM_800_MA);
+
+	pr_debug("Setting current_limit to: 0x%x", haptics->current_limit);
+
+	ret = pmi8998_haptics_write_masked(haptics, HAP_ILIM_CFG_REG(haptics),
+			HAP_ILIM_SEL_MASK, haptics->current_limit);
+	return ret;
+}
+
+/* configuration api for play mode */
+static int pmi8998_haptics_write_play_mode(struct pmi8998_haptics *haptics)
+{
+	u8 val = 0;
+	int ret;
+
+	if (!is_haptics_idle(haptics))
+		return -EBUSY;
+
+	pr_debug("Setting play_mode to: 0x%x", haptics->play_mode);
+
+	val = haptics->play_mode << HAP_WF_SOURCE_SHIFT;
+	ret = pmi8998_haptics_write_masked(haptics, HAP_SEL_REG(haptics),
+			HAP_WF_SOURCE_MASK, val);
+
+	return ret;
+}
+
+static int pmi8998_haptics_write_play_rate(struct pmi8998_haptics *haptics, u16 play_rate)
+{
+	int rc;
+	u8 val[2];
+
+	pr_debug("Setting play_rate to: %d", play_rate);
+
+	if (haptics->last_play_rate == play_rate) {
+		pr_debug("Same rate_cfg %x\n", play_rate);
+		return 0;
+	}
+
+	val[0] = play_rate & HAP_RATE_CFG1_MASK;
+	val[1] = (play_rate >> HAP_RATE_CFG2_SHIFT) & HAP_RATE_CFG2_MASK;
+	rc = pmi8998_haptics_write(haptics, HAP_RATE_CFG1_REG(haptics), val, 2); // We can write both at once
+	if (rc < 0)
+		return rc;
+
+	haptics->last_play_rate = play_rate;
+	return 0;
+}
+
+/*
+ * pmi8998_haptics_set_auto_res() - Auto resonance
+ * allows the haptics to automatically adjust the
+ * speed of the oscillation in order to maintain
+ * the resonant frequency.
+ */
+static int pmi8998_haptics_set_auto_res(struct pmi8998_haptics *haptics, bool enable)
+{
+	int rc = 0;
+	u8 val;
+
+	// LRAs are the only type to support auto res
+	if (haptics->actuator_type != HAP_TYPE_LRA)
+		return 0;
+
+	val = enable ? AUTO_RES_EN_BIT : 0;
+
+	rc = pmi8998_haptics_write_masked(haptics, HAP_TEST2_REG(haptics),
+			AUTO_RES_EN_BIT, val);
+	if (rc < 0)
+		return rc;
+
+	haptics->auto_res_enabled = enable;
+
+	pr_debug("auto_res enabled: %d", enable);
+	return rc;
+}
+
+/*
+ * Write the configured frequency to the device
+ */
+static void pmi8998_haptics_lra_freq_write(struct pmi8998_haptics *haptics)
+{
+	u8 lra_auto_res[2], val;
+	u32 play_rate_code;
+	u16 rate_cfg;
+	int rc;
+
+	// First we read the auto resonance value
+	rc = pmi8998_haptics_read(haptics, HAP_LRA_AUTO_RES_LO_REG(haptics),
+				lra_auto_res, 2);
+	if (rc < 0) {
+		pr_err("Error in reading LRA_AUTO_RES_LO/HI, rc=%d\n", rc);
+		return;
+	}
+
+	play_rate_code =
+		 (lra_auto_res[1] & 0xF0) << 4 | (lra_auto_res[0] & 0xFF);
+
+	pr_debug("lra_auto_res_lo = 0x%x lra_auto_res_hi = 0x%x play_rate_code = 0x%x\n",
+		lra_auto_res[0], lra_auto_res[1], play_rate_code);
+
+	rc = pmi8998_haptics_read(haptics, HAP_STATUS_1_REG(haptics), &val, 1);
+	if (rc < 0)
+		return;
+
+	/*
+	 * If the drive period code read from AUTO_RES_LO and AUTO_RES_HI
+	 * registers is more than the max limit percent variation or less
+	 * than the min limit percent variation specified through DT, then
+	 * auto-resonance is disabled.
+	 */
+
+	if ((val & AUTO_RES_ERROR_BIT) ||
+		((play_rate_code <= haptics->drive_period_code_min_limit) ||
+		(play_rate_code >= haptics->drive_period_code_max_limit))) {
+		if (val & AUTO_RES_ERROR_BIT)
+			pr_err("Auto-resonance error %x\n", val);
+		else
+			pr_debug("play rate %x out of bounds [min: 0x%x, max: 0x%x]\n",
+				play_rate_code,
+				haptics->drive_period_code_min_limit,
+				haptics->drive_period_code_max_limit);
+		rc = pmi8998_haptics_set_auto_res(haptics, false);
+		if (rc < 0)
+			pr_err("Auto-resonance disable failed\n");
+		return;
+	}
+
+	/*
+	 * bits[7:4] of AUTO_RES_HI should be written to bits[3:0] of RATE_CFG2
+	 */
+	lra_auto_res[1] >>= 4;
+	rate_cfg = lra_auto_res[1] << 8 | lra_auto_res[0];
+	rc = pmi8998_haptics_write_play_rate(haptics, rate_cfg);
+	if (rc < 0)
+		pr_err("Error in updating rate_cfg\n");
+}
+
+/*
+ * Write the brake pattern.
+ */
+static int pmi8998_haptics_write_brake(struct pmi8998_haptics *haptics)
+{
+	int ret, i;
+	u32 temp, *ptr;
+	u8 val;
+
+	pr_debug("configuring brake pattern");
+
+	/* Configure BRAKE register */
+	ret = pmi8998_haptics_write_masked(haptics, HAP_EN_CTL2_REG(haptics),
+			BRAKE_EN_BIT, 1);
+	if (ret < 0)
+		return ret;
+
+	ptr = haptics->brake_pat;
+
+	for (i = HAP_BRAKE_PAT_LEN - 1, val = 0; i >= 0; i--) {
+		ptr[i] &= HAP_BRAKE_PAT_MASK;
+		temp = i << 1;
+		val |= ptr[i] << temp;
+	}
+
+	ret = pmi8998_haptics_write(haptics, HAP_BRAKE_REG(haptics), &val, 1);
+	if (ret < 0)
+		return ret;
+
+	return 0;
+}
+
+/* configuration api for buffer mode */
+static int pmi8998_haptics_write_buffer_config(struct pmi8998_haptics *haptics)
+{
+	u8 buf[HAP_WAVE_SAMP_LEN];
+	int rc, i;
+
+	pr_debug("Writing buffer config");
+
+	if (haptics->wave_samp_idx >= ARRAY_SIZE(haptics->wave_samp)) {
+		pr_err("Incorrect wave_samp_idx %d\n",
+			haptics->wave_samp_idx);
+		return -EINVAL;
+	}
+
+	for (i = 0; i < HAP_WAVE_SAMP_LEN; i++) {
+		buf[i] = haptics->wave_samp[i];
+	}
+
+	rc = pmi8998_haptics_write(haptics, HAP_WF_S1_REG(haptics), buf,
+			HAP_WAVE_SAMP_LEN);
+
+	return rc;
+}
+
+// configuration api for haptics wave repeat
+/**
+ * pmi8998_haptics_write_wave_repeat() - write wave repeat values. A false
+ * 	value means that it WONT be written.
+ * @wave_repeat: Write the number of times to repeat each wave (8 samples)
+ * @wave_sample_repeat: Write the number of times to repeat each wave sample
+ */
+static int pmi8998_haptics_write_wave_repeat(struct pmi8998_haptics *haptics,
+					bool wave_repeat, bool wave_sample_repeat)
+{
+	int ret;
+	u8 val = 0, mask = 0;
+
+	if (wave_repeat) {
+		mask = WF_REPEAT_MASK;
+		val = ilog2(1) << WF_REPEAT_SHIFT; // Currently hard coded to default of 1
+	}
+
+	if (wave_sample_repeat) {
+		mask |= WF_S_REPEAT_MASK;
+		val |= ilog2(1);
+	}
+
+	ret = pmi8998_haptics_write_masked(haptics, HAP_WF_REPEAT_REG(haptics),
+			mask, val);
+	return ret;
+}
+
+static int pmi8998_haptics_write_play_control(struct pmi8998_haptics *haptics,
+					enum hap_play_control ctrl)
+{
+	u8 val;
+	int rc;
+
+	switch (ctrl) {
+	case HAP_STOP:
+		val = 0;
+		break;
+	case HAP_PAUSE:
+		val = PAUSE_BIT;
+		break;
+	case HAP_PLAY:
+		val = PLAY_BIT;
+		break;
+	default:
+		return 0;
+	}
+
+	rc = pmi8998_haptics_write(haptics, HAP_PLAY_REG(haptics), &val, 1);
+	if (rc < 0) {
+		pr_err("Error in writing to PLAY_REG, rc=%d\n", rc);
+		return rc;
+	}
+
+	pr_debug("haptics play ctrl: %d\n", ctrl);
+	return rc;
+}
+
+/*
+ * This IRQ is used to load the next wave sample set.
+ * As we only currently support a single sample set, it's unused.
+ */
+static irqreturn_t pmi8998_haptics_play_irq_handler(int irq, void *data) {
+	pr_debug("pmi8998_haptics: play_irq triggered");
+
+	return IRQ_HANDLED;
+}
+
+/*
+ * Fires every ~50ms whilst the haptics are active.
+ * If the SC_FLAG_BIT is set then that means there isn't a short circuit
+ * and we just need to clear the IRQ to indicate that the device should
+ * keep vibrating.
+ *
+ * Otherwise, it means a short circuit situation has occured.
+ * 
+ * Vibration will stop if we don't clear the flag bit, we act as a watchdog
+ * in that sense.
+ */
+static irqreturn_t pmi8998_haptics_sc_irq_handler(int irq, void *data) {
+	struct pmi8998_haptics *haptics = data;
+	int ret;
+	u8 val;
+	s64 sc_delta_time_us;
+	ktime_t temp;
+
+	ret = pmi8998_haptics_read(haptics, HAP_STATUS_1_REG(haptics), &val, 1);
+	if (ret < 0)
+		goto irq_handled;
+
+	if (!(val & SC_FLAG_BIT)) {
+		haptics->sc_count = 0;
+		goto irq_handled;
+	}
+
+	temp = ktime_get();
+	sc_delta_time_us = ktime_us_delta(temp, haptics->last_sc_time);
+	haptics->last_sc_time = temp;
+
+	if (sc_delta_time_us > SC_COUNT_RST_DELAY_US)
+		haptics->sc_count = 0;
+	else
+		haptics->sc_count++;
+
+	// Clear the interrupt flag
+	val = SC_CLR_BIT;
+	ret = pmi8998_haptics_write(haptics, HAP_SC_CLR_REG(haptics), &val, 1);
+	if (ret < 0) {
+		pr_err("Error in writing to SC_CLR_REG, rc=%d\n", ret);
+		goto irq_handled;
+	}
+
+	/* Permanently disable module if SC condition persists */
+	if (haptics->sc_count > SC_MAX_COUNT) {
+		pr_crit("SC persists, permanently disabling haptics\n");
+		ret = pmi8998_haptics_module_enable(haptics, false);
+		if (ret < 0) {
+			pr_err("Error in disabling module, rc=%d\n", ret);
+			goto irq_handled;
+		}
+	}
+
+irq_handled:
+	return IRQ_HANDLED;
+}
+
+
+/************************************************************
+ * pmi8998_haptics_init() - Initialise haptics hardware for use
+ * @haptics: haptics device
+ */
+static int pmi8998_haptics_init(struct pmi8998_haptics *haptics) {
+	int ret;
+	u8 val, mask;
+	u16 lra_res_cal_period, auto_res_mode;
+	u16 play_rate = 0;
+
+	ret = pmi8998_haptics_write_masked(haptics, HAP_CFG1_REG(haptics),
+		HAP_ACT_TYPE_MASK, haptics->actuator_type);
+	if (ret < 0)
+		return ret;
+	
+	// Configure auto resonance
+	// see qpnp_haptics_lra_auto_res_config downstream
+	lra_res_cal_period = 32; // Hard coded default
+	auto_res_mode = HAP_AUTO_RES_ZXD_EOP << LRA_AUTO_RES_MODE_SHIFT; // oneplus 6 default
+	
+	val = ilog2(lra_res_cal_period / HAP_RES_CAL_PERIOD_MIN); // For sdm660 add 1 here
+
+	val |= (auto_res_mode << LRA_AUTO_RES_MODE_SHIFT);
+	// The 1 here is for OPT1, there are 3 options and no documentation
+	// indicating the difference
+	val |= (1 << LRA_HIGH_Z_SHIFT);
+	mask = LRA_AUTO_RES_MODE_MASK | LRA_HIGH_Z_MASK | LRA_RES_CAL_MASK;
+
+	ret = pmi8998_haptics_write_masked(haptics, HAP_LRA_AUTO_RES_REG(haptics),
+			mask, val);
+
+	pr_debug("%s: mode: %d hi_z period: %d cal_period: %d\n", __func__,
+		auto_res_mode, 1,
+		lra_res_cal_period);
+	
+	/* Configure the PLAY MODE register */
+	ret = pmi8998_haptics_write_play_mode(haptics);
+	if (ret < 0)
+		return ret;
+
+	ret = pmi8998_haptics_write_vmax(haptics);
+	if (ret < 0)
+		return ret;
+
+	/* Configure the ILIM register */
+	ret = pmi8998_haptics_write_current_limit(haptics);
+	if (ret < 0)
+		return ret;
+
+	// Configure the debounce for the short-circuit
+	// detection
+	val = HAP_SC_DEB_CYCLES_MAX;
+	ret = pmi8998_haptics_write_masked(haptics, HAP_SC_DEB_REG(haptics),
+			HAP_SC_DEB_MASK, HAP_SC_DEB_CYCLES_MAX);
+	if (ret < 0)
+		return ret;
+
+	// write the wave shape
+	ret = pmi8998_haptics_write_masked(haptics, HAP_CFG2_REG(haptics),
+			HAP_LRA_RES_TYPE_MASK, haptics->wave_shape);
+	if (ret < 0)
+		return ret;
+
+	// The play rate is the wave_rate / cycles per wave
+	play_rate = haptics->play_wave_rate / HAP_RATE_CFG_STEP_US;
+
+	/*
+	 * Configure RATE_CFG1 and RATE_CFG2 registers.
+	 * Note: For ERM these registers act as play rate and
+	 * for LRA these represent resonance period
+	 */
+	ret = pmi8998_haptics_write_play_rate(haptics, play_rate);
+	if (haptics->actuator_type == HAP_TYPE_LRA) {
+		haptics->drive_period_code_max_limit = (play_rate * (100 + 5)) / 100;
+		haptics->drive_period_code_min_limit = (play_rate * (100 - 5)) / 100;
+
+		pr_debug("Drive period code max limit %x min limit %x\n",
+			haptics->drive_period_code_max_limit,
+			haptics->drive_period_code_min_limit);
+	}
+
+	ret = pmi8998_haptics_write_brake(haptics);
+	if (ret < 0)
+		return ret;
+
+	if (haptics->play_mode == HAP_PLAY_BUFFER) {
+		ret = pmi8998_haptics_write_wave_repeat(haptics, true, true);
+		if (ret < 0)
+			return ret;
+
+		ret = pmi8998_haptics_write_buffer_config(haptics);
+	}
+
+	/* setup play irq */
+	if (haptics->play_irq >= 0) {
+		pr_debug("%s: Requesting play IRQ, dev pointer: %p, irq: %d", __func__,
+			haptics->pdev->dev, haptics->play_irq);
+		ret = devm_request_threaded_irq(&haptics->pdev->dev, haptics->play_irq,
+			NULL, pmi8998_haptics_play_irq_handler, IRQF_ONESHOT,
+			"haptics_play_irq", haptics);
+
+		if (ret < 0) {
+			pr_err("Unable to request play(%d) IRQ(err:%d)\n",
+				haptics->play_irq, ret);
+			return ret;
+		}
+
+		//haptics->play_irq_en = true;
+		/* use play_irq only for buffer mode */
+		if (true || haptics->play_mode != HAP_PLAY_BUFFER) {
+			disable_irq(haptics->play_irq);
+			//haptics->play_irq_en = false;
+		}
+	}
+
+	/* setup short circuit1 irq */
+	if (haptics->sc_irq >= 0) {
+		pr_debug("%s: Requesting play IRQ, dev pointer: %p, irq: %d", __func__,
+			haptics->pdev->dev, haptics->play_irq);
+		ret = devm_request_threaded_irq(&haptics->pdev->dev, haptics->sc_irq,
+			NULL, pmi8998_haptics_sc_irq_handler, IRQF_ONESHOT,
+			"haptics_sc_irq", haptics);
+
+		if (ret < 0) {
+			pr_err("Unable to request sc(%d) IRQ(err:%d)\n",
+				haptics->sc_irq, ret);
+			return ret;
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * pmi8998_haptics_set - handler to start/stop vibration
+ * @haptics: pointer to vibrator structure
+ * @on: state to set
+ */
+static int pmi8998_haptics_set(struct pmi8998_haptics *haptics, bool enable)
+{
+	int ret;
+
+	mutex_lock(&haptics->play_lock);
+
+	if (enable) {
+		// Are we in a short circuit state
+		if (haptics->sc_count > SC_MAX_COUNT) {
+			pr_err("Can't play while in short circuit");
+			ret = -1;
+			goto out;
+		}
+		ret = pmi8998_haptics_set_auto_res(haptics, false);
+		if (ret < 0) {
+			pr_err("Error in disabling auto_res, ret=%d\n", ret);
+			goto out;
+		}
+
+		ret = pmi8998_haptics_module_enable(haptics, true);
+		if (ret < 0) {
+			pr_err("Error in enabling module, ret=%d\n", ret);
+			goto out;
+		}
+
+		ret = pmi8998_haptics_write_play_control(haptics, HAP_PLAY);
+		if (ret < 0) {
+			pr_err("Error in enabling play, ret=%d\n", ret);
+			goto out;
+		}
+		
+		ret = pmi8998_haptics_set_auto_res(haptics, true);
+		if (ret < 0) {
+			pr_err("Error in enabling auto_res, ret=%d\n", ret);
+			goto out;
+		}
+	} else {
+		ret = pmi8998_haptics_write_play_control(haptics, HAP_STOP);
+		if (ret < 0) {
+			pr_err("Error in disabling play, ret=%d\n", ret);
+			goto out;
+		}
+
+		ret = pmi8998_haptics_module_enable(haptics, false);
+		if (ret < 0) {
+			pr_err("Error in disabling module, ret=%d\n", ret);
+			goto out;
+		}
+
+		if (haptics->auto_res_enabled)
+			pmi8998_haptics_lra_freq_write(haptics);
+	}
+
+out:
+	mutex_unlock(&haptics->play_lock);
+	return ret;
+}
+
+/*
+ * Work function to update the haptics state.
+ */
+static void pmi8998_process_work(struct work_struct *work)
+{
+	struct pmi8998_haptics *haptics = container_of(work, struct pmi8998_haptics, work);
+
+	int ret;
+	bool enable;
+
+	enable = atomic_read(&haptics->active);
+	pr_debug("%s: state: %d\n", __func__, enable);
+
+	ret = pmi8998_haptics_set(haptics, enable);
+	if (ret < 0)
+		pr_err("Error setting haptics, ret=%d", ret);
+}
+
+/**
+ * pmi8998_haptics_close - callback for input device close
+ * @dev: input device pointer
+ *
+ * Turns off the vibrator.
+ */
+static void pmi8998_haptics_close(struct input_dev *dev)
+{
+	struct pmi8998_haptics *haptics = input_get_drvdata(dev);
+
+	cancel_work_sync(&haptics->work);
+	if (atomic_read(&haptics->active)) {
+		atomic_set(&haptics->active, 0);
+		schedule_work(&haptics->work);
+	}
+}
+
+/**
+ * pmi8998_haptics_play_effect - play haptics effects
+ * @dev: input device pointer
+ * @data: data of effect
+ * @effect: effect to play
+ *
+ * Currently this driver supports only rumble effects.
+ */
+static int pmi8998_haptics_play_effect(struct input_dev *dev, void *data,
+				  struct ff_effect *effect)
+{
+	struct pmi8998_haptics *haptics = input_get_drvdata(dev);
+
+	pr_debug("%s: Rumbling with strong: %d and weak: %d", __func__,
+		effect->u.rumble.strong_magnitude, effect->u.rumble.weak_magnitude);
+
+	haptics->magnitude = effect->u.rumble.strong_magnitude >> 8;
+	if (!haptics->magnitude)
+		haptics->magnitude = effect->u.rumble.weak_magnitude >> 9;
+
+	if (haptics->magnitude) {
+		atomic_set(&haptics->active, 1);
+		haptics->vmax = ((HAP_VMAX_MAX_MV - HAP_VMAX_MIN_MV) * haptics->magnitude) / 0x0e +
+						HAP_VMAX_MIN_MV;
+	} else {
+		atomic_set(&haptics->active, 0);
+		haptics->vmax = HAP_VMAX_MIN_MV;
+	}
+
+	haptics->vmax = constrain(haptics->vmax, HAP_VMAX_MIN_MV, HAP_VMAX_MAX_MV);
+
+	pr_debug("%s: magnitude: %d, vmax: %d", __func__, haptics->magnitude, haptics->vmax);
+
+	pmi8998_haptics_write_vmax(haptics);
+
+	schedule_work(&haptics->work);
+
+	return 0;
+}
+
+static int pmi8998_haptics_probe(struct platform_device *pdev)
+{
+	struct pmi8998_haptics *haptics;
+	struct device_node *node;
+	struct input_dev *input_dev;
+	int ret;
+	unsigned int val;
+	int temp, i;
+
+	haptics = devm_kzalloc(&pdev->dev, sizeof(*haptics), GFP_KERNEL);
+	if (!haptics)
+		return -ENOMEM;
+
+	haptics->regmap = dev_get_regmap(pdev->dev.parent, NULL);
+	if (!haptics->regmap)
+		return -ENODEV;
+
+	node = pdev->dev.of_node;
+
+	haptics->pdev = pdev;	
+
+	ret = of_property_read_u32(node, "reg", &temp);
+	if (ret < 0) {
+		pr_err("Couldn't find reg in node = %s ret = %d\n",
+			node->full_name, ret);
+		return ret;
+	}
+
+	if (temp <= 0) {
+		pr_err("Invalid base address: 0x%x\n", temp);
+		return -EINVAL;
+	}
+	haptics->base = (u16)temp;
+
+	haptics->play_irq = platform_get_irq_byname(pdev, "hap-play-irq");
+	if (haptics->play_irq < 0) {
+		dev_err(&pdev->dev, "Unable to get play irq\n");
+		ret = haptics->play_irq;
+		goto register_fail;
+	}
+
+	haptics->sc_irq = platform_get_irq_byname(pdev, "hap-sc-irq");
+	if (haptics->sc_irq < 0) {
+		dev_err(&pdev->dev, "Unable to get sc irq\n");
+		ret = haptics->sc_irq;
+		goto register_fail;
+	}
+
+	haptics->actuator_type = HAP_TYPE_LRA;
+
+	haptics->play_mode = HAP_PLAY_BUFFER;
+
+	haptics->play_wave_rate = HAP_WAVE_PLAY_RATE_DEF_US;
+	ret = of_property_read_u32(node,
+			"qcom,wave-play-rate-us", &val);
+	if (!ret) {
+		haptics->play_wave_rate = val;
+	} else if (ret != -EINVAL) {
+		pr_err("Unable to read play rate ret=%d\n", ret);
+		goto register_fail;
+	}
+
+	haptics->wave_shape = HAP_WAVE_SINE;
+	ret = of_property_read_u32(node, "qcom,wave-shape", &val);
+	if (!ret) {
+		if (val != HAP_WAVE_SINE && val != HAP_WAVE_SQUARE) {
+			dev_err(&pdev->dev, "qcom,wave-shape is invalid: %d\n", val);
+			ret = -EINVAL;
+			goto register_fail;
+		}
+		haptics->wave_shape = val;
+	}
+
+	haptics->brake_pat[0] = 0x3;
+	haptics->brake_pat[1] = 0x3;
+	haptics->brake_pat[2] = 0x3;
+	haptics->brake_pat[3] = 0x3;
+
+	haptics->wave_samp_idx = 0;
+
+	for (i = 0; i < HAP_WAVE_SAMP_LEN; i++)
+			haptics->wave_samp[i] = HAP_WF_SAMP_MAX;
+
+	haptics->play_wave_rate =
+		constrain(haptics->play_wave_rate,
+		HAP_WAVE_PLAY_RATE_MIN_US, HAP_WAVE_PLAY_RATE_MAX_US);
+
+	ret = pmi8998_haptics_init(haptics);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "Error in configuring haptics, ret=%d\n",
+			ret);
+		goto register_fail;
+	}
+
+	platform_set_drvdata(pdev, haptics);
+
+	input_dev = devm_input_allocate_device(&pdev->dev);
+	if (!input_dev)
+		return -ENOMEM;
+
+	INIT_WORK(&haptics->work, pmi8998_process_work);
+	haptics->haptics_input_dev = input_dev;
+
+	input_dev->name = "pmi8998_haptics";
+	input_dev->id.version = 1;
+	input_dev->close = pmi8998_haptics_close;
+	input_set_drvdata(input_dev, haptics);
+	// Figure out how to make this FF_PERIODIC
+	input_set_capability(haptics->haptics_input_dev, EV_FF, FF_RUMBLE);
+
+	ret = input_ff_create_memless(input_dev, NULL,
+					pmi8998_haptics_play_effect);
+	if (ret) {
+		dev_err(&pdev->dev,
+			"couldn't register vibrator as FF device\n");
+		goto register_fail;
+	}
+
+	ret = input_register_device(input_dev);
+	if (ret) {
+		dev_err(&pdev->dev, "couldn't register input device\n");
+		goto register_fail;
+	}
+
+	return 0;
+
+register_fail:
+	cancel_work_sync(&haptics->work);
+	mutex_destroy(&haptics->play_lock);
+
+	return ret;
+}
+
+static int __maybe_unused pmi8998_haptics_suspend(struct device *dev)
+{
+	struct pmi8998_haptics *haptics = dev_get_drvdata(dev);
+
+	cancel_work_sync(&haptics->work);
+	pmi8998_haptics_set(haptics, false);
+
+	return 0;
+}
+
+static SIMPLE_DEV_PM_OPS(pmi8998_haptics_pm_ops, pmi8998_haptics_suspend, NULL);
+
+static int qpnp_haptics_remove(struct platform_device *pdev)
+{
+	struct pmi8998_haptics *haptics = dev_get_drvdata(&pdev->dev);
+
+	cancel_work_sync(&haptics->work);
+	mutex_destroy(&haptics->play_lock);
+	dev_set_drvdata(&pdev->dev, NULL);
+
+	return 0;
+}
+
+static void qpnp_haptics_shutdown(struct platform_device *pdev)
+{
+	struct pmi8998_haptics *haptics = dev_get_drvdata(&pdev->dev);
+
+	cancel_work_sync(&haptics->work);
+
+	pmi8998_haptics_set(haptics, false);
+}
+
+static const struct of_device_id pmi8998_haptics_id_table[] = {
+	{ .compatible = "qcom,qpnp-haptics-buffer" },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, pmi8998_haptics_id_table);
+
+static struct platform_driver pmi8998_haptics_driver = {
+	.probe		= pmi8998_haptics_probe,
+	.remove		= qpnp_haptics_remove,
+	.shutdown	= qpnp_haptics_shutdown,
+	.driver		= {
+		.name	= "qpnp-haptics",
+		.pm	= &pmi8998_haptics_pm_ops,
+		.of_match_table = pmi8998_haptics_id_table,
+	},
+};
+module_platform_driver(pmi8998_haptics_driver);
+
+MODULE_ALIAS("platform:pmi8998_haptics");
+MODULE_DESCRIPTION("PMI8998 vibrator driver based on ff-memless framework");
+MODULE_LICENSE("GPL v2");
+MODULE_AUTHOR("Caleb Connolly <caleb@connolly.tech>");
diff --git a/include/dt-bindings/input/qcom,pmi8998-haptics.h b/include/dt-bindings/input/qcom,pmi8998-haptics.h
new file mode 100644
index 000000000000..68c1e7c5eb55
--- /dev/null
+++ b/include/dt-bindings/input/qcom,pmi8998-haptics.h
@@ -0,0 +1,31 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * This header provides constants for gpio keys bindings.
+ */
+
+#ifndef _DT_BINDINGS_QCOM_PMIC_8998_HAPTICS_
+#define _DT_BINDINGS_QCOM_PMIC_8998_HAPTICS_
+
+// Actuator types
+#define HAP_TYPE_LRA		0
+#define HAP_TYPE_ERM		1
+
+// LRA Wave type
+#define HAP_WAVE_SINE		0
+#define HAP_WAVE_SQUARE		1
+
+// Play modes
+#define HAP_PLAY_DIRECT		0
+#define HAP_PLAY_BUFFER		1
+#define HAP_PLAY_AUDIO		2
+#define HAP_PLAY_PWM		3
+
+#define HAP_PLAY_MAX		HAP_PLAY_PWM
+
+#define HAP_AUTO_RES_NONE		0
+#define HAP_AUTO_RES_ZXD		1
+#define HAP_AUTO_RES_QWD		2
+#define HAP_AUTO_RES_MAX_QWD	3
+#define HAP_AUTO_RES_ZXD_EOP	4
+
+#endif /* _DT_BINDINGS_QCOM_PMIC_8998_HAPTICS_ */
-- 
2.30.2

